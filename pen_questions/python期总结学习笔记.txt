一、关键特性
1.1. Python是一种解释型语言，这意味着，与C,C++不同，Python不需要在运
行之前进行编译。它是边运行边解释。
1.2. Python是动态类型化的，这意味着当你声明它们或类似的东西时，你不需
要声明变量的类型。你可以x = 1, 然后x = 'abc' 没有错误.
1.3. Python非常适合面向对象编程,因为它允许定义类以及组合和继承.Python
没有访问修饰符(如C++的public, private).
1.4. 在Python中函数一等对象,这意味着它们可以在运行时动态创建,能赋值给
变量或作为参数传给函数,还能作为函数的返回值.
1.5. Python代码容易上手,开发速度很快,但运行速度通常比编译语言慢,幸运是,
Python允许包含基于C的扩展,所以瓶颈可以被优化掉,比如,numpy包就是一个很好
的例子,它非常快,因为它所做的很多运算在底部都是用C编写的!
二、深浅拷贝区别
2.1. 对象的赋值
Python中对象的赋值实际上是简单的对象引用也就是说,当你创建一个对象,然后
把它复制给另一个变量的时候,Python并没有拷贝这个对象,而是拷贝了这个对象
的引用.
>>> lst1 = [1, 2, 3, 4];lst2 = lst1
>>> print(lst1, id(lst1));print(lst2, id(lst2))
[1, 2, 3, 4] 2590336549640
[1, 2, 3, 4] 2590336549640
>>> lst1.append(5) #lst1和lst2都指向同一块区域,改变了lst1,lst2也会改变.
>>> print(lst1, id(lst1));print(lst2, id(lst2))
[1, 2, 3, 4, 5] 2590336549640
[1, 2, 3, 4, 5] 2590336549640
2.2. 浅拷贝
一般使用copy.copy(),可以进行对象的浅拷贝,它复制了对象但对于对象中的元素,
依然使用原始的引用.
>>> import copy
>>> a = [1, [2, 3, 4]]
>>> b = a.copy()
>>> print(a, id(a)); print(b, id(b))
[1, [2, 3, 4]] 1681072526792
[1, [2, 3, 4]] 1681072468488
>>> a[1].append(5) #改变了a列表里面的子列表[2, 3, 4]
>>> print(a, id(a)); print(b, id(b))
[1, [2, 3, 4, 5]] 1681072526792
[1, [2, 3, 4, 5]] 1681072468488
	使用copy对a进行浅拷贝,b复制了a对象,但是b里面的[2, 3, 4]和a里面的[2, 3, 4]
其实都是指向同一块内存地址,所以改变了a[1]之后, b里面的b[1]也发生了改变!
2.3. 深度拷贝
深度拷贝需要用copy.deepcopy()进行深拷贝.它会复制一个容器对象,以及它里面的所有
元素(包含元素的子元素)
>>> import copy
>>> a = [1, [2, 3, 4]]
>>> b = copy.deepcopy(a)
>>> 
a[1].append(5)
>>> print('a[1] addr:', id(a[1])); print('b[1] addr:', id(b[1]))
a[1] addr: 1681072771784
b[1] addr: 1681072708232
当对a列表进行深度拷贝之后,b复制了a的对象,但是b里面的[2, 3, 4]和a里面的[2, 3, 4]
其实都指向不同的内存地址.
>>a[1].append(5); print(a); print(b) 
[1, [2, 3, 4, 5]] 
[1, [2, 3, 4]]
因为是深度拷贝,改变了a[1],b[1]内容不会改变.
三、== 和 is 的区别
3.1. is是判读对象标识符是否一致, 而是==是判读两个对象的内容是否相等!
	x is y 相当于 id(x) == id(y)
	==是检查两个对象的内容是否相等,会调用对象的内部__eq__().
>>> a = 'abc'
>>> b = ''.join(['a', 'b', 'c'])
>>> print(a is b)
False
>>> print(a == b)
True
四、多线程问题
线程如何在Python中实现
Python有一个多线程包threading, 可以使用多线程来加快你的代码.但是Python
有一个叫做Global Interpreter Lock(GIL)的构造.GIL确保只有一个'线程'可以
在任何时候执行.
线程获取GIL,做一些工作,然后将GIL传递到下一个线程.这种情况发生得非常快,
所以对人眼而言,它可能看起来像你的线程并行执行,但它们实际上只是轮流使用
相同的CPU内核.因此GIL的存在使得Python中的多线程无法真正的利用多核的优势
来提高性能.
对于IO密集型操作,在等待操作系统返回的时候会释放GIL;再比如爬虫因为有等待
的服务的响应时间,可以利用多线程来加速!但是对于CPU密集型操作,只能通过多进
程Multiprocess来加速.
五、猴子补丁
	是一种非常Pythonic的用法,即函数在python中可以像使用变量一样对它进行赋值
等操作,我们可以在运行时动态替换模块,俗称手法称为猴子补丁!我们通过对Myclass.f
重新赋值,动态改变了输出的结果.

#m.py
class MyClass(object):
    def f(self):
        print('f()')
        
import m
def monkey_f(self):
    print('monkey_f()')

m.MyClass.f = monkey_f
obj = m.MyClass()

obj.f()

六、负值索引
	Python中的负数index是用来做什么的?
Python中的序列是索引的,它由正数和负数组成.正的数字使用'0'作为第一个
索引,'1'作为第二个索引.
负数的索引从'-1'开始,表示序列中的最后一个索引,'-2'作为倒数第二个索引,
序列像正数一样向前.
负数索引也可以用来非常方便的切片,比如:
>>> s = 'abcdef'
>>> print(s[1:-1])
bcde
七、new | init区别
__new__ 和__init__的区别:
7.1. __init__为初始化方法,而__new__方法才是真正的构造函数.只有继承了
object的新式类才有__new__.
7.2. __new__至少要有一个参数cls,代表要实例化的类,此参数在实例化时由
Python解释器自动提供,__new__必须要有返回值,返回实例化出来的实例.
7.3. __init__有一个参数self,就是这个__new__返回的实例,先运行__new__
然后才运行__init__.
7.4. __init__在__new__的基础上可以完成一些其它初始化的动作,__init__不
需要返回值.
八、*args和**kwargs
*args是可变参数,一般用来表示我们不能确定多少参数将被传递给函数,或者如果
我们想用列表或元组的方式传递给函数.
>>> def fun(first, *rest):
				print('first:', first)
				print('rest:', rest)

>>> fun(1, 2, 3, 4, 5)
first: 1
rest: (2, 3, 4, 5)
**kwargs是可变关键字参数,当我们不知道有多少关键字参数会传递给一个函数
时,或者想把一个字典作为关键字参数时使用
>>> def fun(name, value, **kwargs):
				print(name, value)
				for k, v in kwargs.items():
							print(k, ':', v)
>>> fun('jack', 20, sex='male', height=175)
jack 20
sex : male
height : 175
注:*args和**kwargs可以同时在函数的定义中,但是*args必须在**kwargs前面.
